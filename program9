9. Write a program to do the following: You have given a collection of 8
points. P1=[0.1,0.6] P2=[0.15,0.71] P3=[0.08,0.9] P4=[0.16, 0.85]
P5=[0.2,0.3] P6=[0.25,0.5] P7=[0.24,0.1] P8=[0.3,0.2]. Perform the k-mean
clustering with initial centroids as m1=P1 =Cluster#1=C1 and
m2=P8=cluster#2=C2. Answer the following 1] Which cluster does P6
belong to? 2] What is the population of a cluster around m2? 3] What is
the updated value of m1 and m2?

# program9_kmeans_manual.py
# Manual 1-step k-means (pure Python)

import math

# Points (mock CSV -> loaded into a list/dict)
points = {
    'P1': (0.1, 0.6),
    'P2': (0.15, 0.71),
    'P3': (0.08, 0.9),
    'P4': (0.16, 0.85),
    'P5': (0.2, 0.3),
    'P6': (0.25, 0.5),
    'P7': (0.24, 0.1),
    'P8': (0.3, 0.2)
}

# Initial centroids
m1 = points['P1']   # Cluster C1 initial centroid
m2 = points['P8']   # Cluster C2 initial centroid

def euclidean(a, b):
    return math.hypot(a[0] - b[0], a[1] - b[1])

# Step 1: compute distances and assign clusters
assignments = {}   # name -> ('C1' or 'C2', d_to_m1, d_to_m2)
for name, p in points.items():
    d1 = euclidean(p, m1)
    d2 = euclidean(p, m2)
    cluster = 'C1' if d1 <= d2 else 'C2'   # tie -> C1
    assignments[name] = (cluster, d1, d2)

# Print distances and assignments (paper-style)
print("Point |   x     y   |  dist->m1  |  dist->m2  | Assigned")
print("------------------------------------------------------")
for name in sorted(points.keys()):
    p = points[name]
    cluster, d1, d2 = assignments[name]
    print(f"{name:3s}   | {p[0]:6.3f}, {p[1]:6.3f} | {d1:9.6f} | {d2:9.6f} | {cluster}")

# Q1: Which cluster does P6 belong to?
p6_cluster = assignments['P6'][0]
print(f"\nAnswer 1) P6 belongs to: {p6_cluster}")

# Q2: What is the population of the cluster around m2? (i.e., count points assigned to C2)
cluster_counts = {'C1': 0, 'C2': 0}
for v in assignments.values():
    cluster_counts[v[0]] += 1
print(f"Answer 2) Population of cluster around m2 (C2): {cluster_counts['C2']}")

# Step 2: Recompute centroids (mean of points assigned to each cluster)
def recompute_centroid(assignments, cluster_name):
    xs, ys = [], []
    for name, (cluster, _, _) in assignments.items():
        if cluster == cluster_name:
            x, y = points[name]
            xs.append(x); ys.append(y)
    if not xs:
        return None
    return (sum(xs)/len(xs), sum(ys)/len(ys))

m1_new = recompute_centroid(assignments, 'C1')
m2_new = recompute_centroid(assignments, 'C2')

# Print updated centroids
print("\nAnswer 3) Updated centroids after one assignment step:")
print(f"  m1 (new) = ({m1_new[0]:.6f}, {m1_new[1]:.6f})")
print(f"  m2 (new) = ({m2_new[0]:.6f}, {m2_new[1]:.6f})")
